## 线程

Python 提供了多个模块来支持多线程编程，包括 thread、 threading 和 Queue 模块等。

- thread 模块：提供了基本的线程和锁定支持。
- threading 模块：提供了更高级别、功能更全面的线程管理。
- Queue 模块：用户可以创建一个队列数据结构，用于在多线程之间进行共享。

推荐使用threading模块比thread模块更高级。



### 1 Threading模块的类

| 类        | 描述                                         |
| --------- | -------------------------------------------- |
| Thread    | 线程对象                                     |
| Lock      | 互斥锁                                       |
| Condition | 条件变量                                     |
| Event     | 事件，该事件发生后所有等待该事件的线程将激活 |
| Semaphore | 信号量（计数器）                             |
| Timer     | 定时器，运行前会等待一段时间                 |
| Barrier   | 创建一个障碍，必须达到指定数量线程才开始运行 |



### 2 Thread类的方法

| 方法名       | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| run()        | 用以表示线程活动的方法                                       |
| start()      | 启动线程活动                                                 |
| join([time]) | 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生 |
| isAlive()    | 返回线程是否活动的                                           |
| getName()    | 返回线程名                                                   |
| setName()    | 设置线程名                                                   |



### 3 创建线程

```python
# 1.单线程执行
import  time
def say():
    print("Hello Python")
    time.sleep(1)

if __name__=='__main__':
    for i in range(5):
        say()
```



```python
# 2.threading.Thread创建线程
import  time
import threading
def say():
    print("Hello Python")
    time.sleep(1)

if __name__=='__main__':
    for i in range(5):
        t=threading.Thread(target=say)
        t.start()   #启动线程，即让线程开始执行
```



```python
# 3.主线程会等待所有的子线程结束后才结束
import  time
import threading
def sing():
    for i in range(3):
        print("正在唱歌:{0}".format(i))
        time.sleep(1)
def dance():
    for i in range(3):
        print("正在跳舞:{0}".format(i))
        time.sleep(1)
if __name__=='__main__':
    print("开始: ",time.ctime())
    t1=threading.Thread(target=sing)
    t2=threading.Thread(target=dance)
    t1.start()
    t2.start()
    time.sleep(5)
    print("结束: ",time.ctime())
```



```python
# 4.查看线程数量
import  time
import threading
def sing():
    for i in range(3):
        print("正在唱歌:{0}".format(i))
        time.sleep(1)
def dance():
    for i in range(3):
        print("正在跳舞:{0}".format(i))
        time.sleep(1)
if __name__=='__main__':
    print("开始: ",time.ctime())
    t1=threading.Thread(target=sing)
    t2=threading.Thread(target=dance)
    t1.start()
    t2.start()
    while True:
        length=len(threading.enumerate())
        print("当前运行的线程数为:{0}".format(length))
        if length<=1:
            break
        time.sleep(0.5)
```



```python
# 5.线程执行代码的封装
import time
import threading
class MyThread(threading.Thread):
    def run(self):
        for i in range(3):
            time.sleep(1)
            msg="I'm "+self.name+" "+str(i)     #name属性中保存的是当前线程的名字
            print(msg)
if __name__=='__main__':
    t=MyThread()
    t.start()
```



```python
# 6.线程的执行顺序
import time
import threading
class MyThread(threading.Thread):
    def run(self):
        for i in range(3):
            time.sleep(1)
            msg="I'm "+self.name+" "+str(i)     #name属性中保存的是当前线程的名字
            print(msg)
def test():
    for i in range(5):
        t=MyThread()
        t.start()

if __name__=='__main__':
    test()
```



```python
# 7.共享全局变量
import threading
import time
g_num=100

def work1():
    global g_num
    for i in range(3):
        g_num+=1
    print("work1 g_num is {0}".format(g_num))

def work2():
    global g_num
    print("work2 g_num is {0}".format(g_num))

print("开始 g_num is {0}".format(g_num))

t1=threading.Thread(target=work1)
t1.start()
time.sleep(1)
t2=threading.Thread(target=work2)
t2.start()
```



```python
# 8.列表当做实参传递到线程中
import threading
import time

def work1(nums):
    nums.append(44)
    print("work1 : {0}".format(nums))

def work2(nums):
    time.sleep(1)
    print("work2 : {0}".format(nums))

g_nums=[11,22,33]
t1=threading.Thread(target=work1,args=(g_nums,))
t1.start()
t2=threading.Thread(target=work2,args=(g_nums,))
t2.start()
```



```python
# 9.使用互斥锁完成2个线程对同一个全局变量各加100万次的操作
import threading
import time
g_num=0
def test1(num):
    global g_num
    for i in range(num):
        lock.acquire()
        g_num+=1
        lock.release()
    print("---test1---g_num=%d" % g_num)
def test2(num):
    global g_num
    for i in range(num):
        lock.acquire()
        g_num+=1
        lock.release()
    print("---test2---g_num=%d" % g_num)
lock=threading.Lock()
p1=threading.Thread(target=test1,args=(1000000,))
p1.start()
p2=threading.Thread(target=test2,args=(1000000,))
p2.start()
while len(threading.enumerate())!=1:
    time.sleep(1)
print("2个线程对同一个全局变量操作之后的最终结果是:%s" % g_num)
```



```python
# 10.线程死锁例子
import threading
import time

class MyThead1(threading.Thread):
    def run(self):
        lock1.acquire()
        print(self.name + '----do1---up----')
        time.sleep(1)
        lock2.acquire()
        print(self.name + '----do1---down----')
        lock2.release()
        lock1.release()

class MyThead2(threading.Thread):
    def run(self):
        lock2.acquire()
        print(self.name + '----do2---up----')
        time.sleep(1)
        lock1.acquire()
        print(self.name + '----do2---down----')
        lock1.release()
        lock2.release()

lock1=threading.Lock()
lock2=threading.Lock()

if __name__=='__main__':
    t1=MyThead1()
    t2=MyThead2()
    t1.start()
    t2.start()
```

