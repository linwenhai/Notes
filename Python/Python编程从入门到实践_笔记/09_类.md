## 类

`面向对象编程`是最有效的软件编写方法之一。

根据`类`来创建对象被称为`实例化`，这让你能够使用类的实例。



### 1 创建Dog 类

在Python中，首字母大写的名称指的是类。

类中的函数称为`方法`，如方法`__init__()`

形参self必不可少，还必须位于其他形参的前面。

可通过实例访问的变量称为`属性`。

dog.py

```python
class Dog():
	"""一次模拟小狗的简单尝试"""
    
	def __init__(self, name, age):
		"""初始化属性name和age"""
		self.name = name
		self.age = age

	def sit(self):
		"""模拟小狗被命令时蹲下"""
		print(self.name.title() + " is now sitting.")

	def roll_over(self):
		"""模拟小狗被命令时打滚"""
		print(self.name.title() + " rolled over!")
```



### 2 根据类创建实例

使用句点表示法，访问实例的属性，如my_dog.name

```python
class Dog():
	--snip--

my_dog = Dog('willie', 6)
print("My dog's name is " + my_dog.name.title() + ".")
print("My dog is " + str(my_dog.age) + " years old.")
```



使用句点表示法，调用Dog类中定义的方法，如my_dog.sit()

```python
class Dog():
	--snip--
    
my_dog = Dog('willie', 6)
my_dog.sit()
my_dog.roll_over()
```



```python
# 创建多个实例
class Dog():
	--snip--

my_dog = Dog('willie', 6)
your_dog = Dog('lucy', 3)

print("My dog's name is " + my_dog.name.title() + ".")
print("My dog is " + str(my_dog.age) + " years old.")
my_dog.sit()

print("\nYour dog's name is " + your_dog.name.title() + ".")
print("Your dog is " + str(your_dog.age) + " years old.")
your_dog.sit()
```



### 3 创建Car类

方法`__init__()`接受形参的值，并将它们存储在根据这个类创建的实例的属性中。

```python
class Car():
	"""一次模拟汽车的简单尝试"""

    def __init__(self, make, model, year):
		"""初始化描述汽车的属性"""
		self.make = make
		self.model = model
		self.year = year

	def get_descriptive_name(self):
		"""返回整洁的描述性信息"""
		long_name = str(self.year) + ' ' + self.make + ' ' + self.model
		return long_name.title()

my_new_car = Car('audi', 'a4', 2016)
print(my_new_car.get_descriptive_name())
```



### 4 给属性指定默认值

```python
class Car():
	def __init__(self, make, model, year):
		"""初始化描述汽车的属性"""
		self.make = make
		self.model = model
		self.year = year
		self.odometer_reading = 0
        	"""给属性指定默认值"""

    def get_descriptive_name(self):
		--snip--

	def read_odometer(self):
		"""打印一条指出汽车里程的消息"""
		print("This car has " + str(self.odometer_reading) + " miles on it.")

my_new_car = Car('audi', 'a4', 2016)
print(my_new_car.get_descriptive_name())
my_new_car.read_odometer()
```



### 5 修改属性的值

1】直接修改属性的值

```python
class Car():
	--snip--

my_new_car = Car('audi', 'a4', 2016)
print(my_new_car.get_descriptive_name())
my_new_car.odometer_reading = 23
	"""直接修改属性的值"""
my_new_car.read_odometer()
```



2】通过方法修改属性的值

```python
class Car():
	--snip--

	def update_odometer(self, mileage):
		"""将里程表读数设置为指定的值"""
		self.odometer_reading = mileage

my_new_car = Car('audi', 'a4', 2016)
print(my_new_car.get_descriptive_name())

my_new_car.update_odometer(23)
my_new_car.read_odometer()
```



3】通过方法对属性的值进行递增

```python
class Car():
    """模拟汽车"""

    def __init__(self,make,model,year):
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

    def get_descriptive_name(self):
        """返回描述性信息"""
        long_name = str(self.year) + ' ' + self.make + ' ' + self.model
        return long_name.title()

    def read_odometer(self):
        """打印汽车历程信息"""
        print("This car has " + str(self.odometer_reading) + " miles on it.")

    def update_odometer(self,mileage):
        """将里程表读数设置为指定的值"""
        self.odometer_reading = mileage

    def increment_odometer(self,miles):
        """将里程表读数增加指定的量"""
        self.odometer_reading += miles

my_new_car = Car('audi','A4',2016)
print(my_new_car.get_descriptive_name())

my_new_car.update_odometer(1000)
my_new_car.read_odometer()

my_new_car.increment_odometer(500)
my_new_car.read_odometer()
```

>输出结果：
>
>2016 Audi A4
>This car has 1000 miles on it.
>This car has 1500 miles on it.



### 6 继承

一个类继承另一个类时，它将自动获得另一个类的所有属性和方法；原有的类称为父类，而新类称为子类。

super()是一个特殊函数，帮助Python将父类和子类关联起来。

electric_car.py

```python
class Car():
    """模拟汽车"""

    def __init__(self,make,model,year):
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

    def get_descriptive_name(self):
        """返回描述性信息"""
        long_name = str(self.year) + ' ' + self.make + ' ' + self.model
        return long_name.title()

    def read_odometer(self):
        """打印汽车历程信息"""
        print("This car has " + str(self.odometer_reading) + " miles on it.")

    def update_odometer(self,mileage):
        """将里程表读数设置为指定的值"""
        if mileage >= self.odometer_reading:
            self.odometer_reading = mileage
        else:
            print("You can't roll back an odometer!")

    def increment_odometer(self,miles):
        """将里程表读数增加指定的量"""
        self.odometer_reading += miles

class Electricar(Car):
    """电动汽车的独特之处"""

    def __init__(self,make,model,year):
        super().__init__(make,model,year)

my_tesla = Electricar('tesla','model s',2016)
print(my_tesla.get_descriptive_name())
```

>输出结果：
>
>2016 Tesla Model S



### 7 给子类定义属性和方法

```python
class Car():
	--snip--
    
class ElectricCar(Car):

	def __init__(self, make, model, year):
		"""
		电动汽车的独特之处
		初始化父类的属性，再初始化电动汽车特有的属性
		"""
		super().__init__(make, model, year)
		self.battery_size = 80
        
	def describe_battery(self):
		"""打印一条描述电瓶容量的消息"""
		print("This car has a " + str(self.battery_size) + "-kWh battery.")
        
my_tesla = ElectricCar('tesla', 'model s', 2016)
print(my_tesla.get_descriptive_name())
my_tesla.describe_battery()
```

>输出结果：
>
>2016 Tesla Model S
>This car has a 80-kWh battery.



### 8 重写父类的方法

对于父类的方法，只要它不符合子类模拟的实物的行为，都可对其进行重写。为此，可在子类中定义一个这样的方法，即它与要重写的父类方法同名。



### 9 将实例用作属性

```python
class Car():
	--snip--

class Battery():
	"""一次模拟电动汽车电瓶的简单尝试"""
	def __init__(self, battery_size=70):
		"""初始化电瓶的属性"""
		self.battery_size = battery_size
        
	def describe_battery(self):
		"""打印一条描述电瓶容量的消息"""
		print("This car has a " + str(self.battery_size) + "-kWh battery.")
        
class ElectricCar(Car):
	"""电动汽车的独特之处"""
	def __init__(self, make, model, year):
		"""
		初始化父类的属性，再初始化电动汽车特有的属性
		"""
		super().__init__(make, model, year)
		self.battery = Battery()
        
my_tesla = ElectricCar('tesla', 'model s', 2016)

print(my_tesla.get_descriptive_name())
my_tesla.battery.describe_battery()
```

>输出结果：
>
>2016 Tesla Model S
>This car has a 70-kWh battery.



给Battery类添加一个方法

```python
class Car():
	--snip--
    
class Battery():
	--snip--
	def get_range(self):
		"""打印一条消息，指出电瓶的续航里程"""
		if self.battery_size == 70:
			range = 240
		elif self.battery_size == 85:
			range = 270
		message = "This car can go approximately " + str(range)
		message += " miles on a full charge."
		print(message)
        
class ElectricCar(Car):
	--snip--

my_tesla = ElectricCar('tesla', 'model s', 2016)
print(my_tesla.get_descriptive_name())
my_tesla.battery.describe_battery()
my_tesla.battery.get_range()
```

>输出结果：
>
>2016 Tesla Model S
>This car has a 70-kWh battery.
>This car can go approximately 240 miles on a full charge.



### 10 导入类

导入类是一种有效的编程方式。

创建模块car.py

```python
"""一个可用于表示汽车的类"""
class Car():
    """一次模拟汽车的简单尝试"""

    def __init__(self, make, model, year):
        """初始化描述汽车的属性"""
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

    def get_descriptive_name(self):
        """返回整洁的描述性名称"""
        long_name = str(self.year) + ' ' + self.make + ' ' + self.model
        return long_name.title()

    def read_odometer(self):
        """打印一条消息，指出汽车的里程"""
        print("This car has " + str(self.odometer_reading) + " miles on it.")

    def update_odometer(self, mileage):
        """
        将里程表读数设置为指定的值
        拒绝将里程表往回拨
        """
        if mileage >= self.odometer_reading:
            self.odometer_reading = mileage
        else:
            print("You can't roll back an odometer!")

    def increment_odometer(self, miles):
        """将里程表读数增加指定的量"""
        self.odometer_reading += miles
```



创建my_car.py，打开模块car，并导入其中的Car类

```python
from car import Car

my_new_car = Car('audi', 'a4', 2016)
print(my_new_car.get_descriptive_name())

my_new_car.odometer_reading = 23
my_new_car.read_odometer()
```

>输出结果：
>
>2016 Audi A4
>This car has 23 miles on it.



### 11 在一个模块中存储多个类

创建模块car.py

```python
"""一组用于表示燃油汽车和电动汽车的类"""
class Car():
	--snip--

    
class Battery():
	"""一次模拟电动汽车电瓶的简单尝试"""
    
	def __init__(self, battery_size=60):
		"""初始化电瓶的属性"""
		self.battery_size = battery_size
        
	def describe_battery(self):
		"""打印一条描述电瓶容量的消息"""
		print("This car has a " + str(self.battery_size) + "-kWh battery.")
        
	def get_range(self):
		"""打印一条描述电瓶续航里程的消息"""
		if self.battery_size == 70:
			range = 240
		elif self.battery_size == 85:
			range = 270
		message = "This car can go approximately " + str(range)
		message += " miles on a full charge."        
		print(message)
        
        
class ElectricCar(Car):
	"""模拟电动汽车的独特之处"""
	def __init__(self, make, model, year):
		"""
		初始化父类的属性，再初始化电动汽车特有的属性
		"""
		super().__init__(make, model, year)
		self.battery = Battery()
```



创建模块my_electric_car.py

```python
from car import ElectricCar

my_tesla = ElectricCar('tesla', 'model s', 2016)

print(my_tesla.get_descriptive_name())
my_tesla.battery.describe_battery()
my_tesla.battery.get_range()
```

>输出结果：
>
>2016 Tesla Model S
>This car has a 70-kWh battery.
>This car can go approximately 240 miles on a full charge.



### 12 从一个模块中导入多个类

模块my_cars.py

```python
from car import Car, ElectricCar

my_beetle = Car('volkswagen', 'beetle', 2016)
print(my_beetle.get_descriptive_name())

my_tesla = ElectricCar('tesla', 'roadster', 2016)
print(my_tesla.get_descriptive_name())
```

>输出结果：
>
>2016 Volkswagen Beetle
>2016 Tesla Roadster



### 13 导入整个模块

模块my_cars.py

由于创建类实例的代码都包含模块名，因此不会与当前文件使用的任何名称发生冲突。

```python
import car

my_beetle = car.Car('volkswagen', 'beetle', 2016)
print(my_beetle.get_descriptive_name())

my_tesla = car.ElectricCar('tesla', 'roadster', 2016)
print(my_tesla.get_descriptive_name())
```



### 14 在一个模块中导入另一个模块

模块car.py

```python
"""一组用于表示燃油汽车和电动汽车的类"""
class Car():
	--snip--
```



模块electric_car.py

```python
"""一组可用于表示电动汽车的类"""
from car import Car

class Battery():
	--snip--
    
class ElectricCar(Car):
	--snip--
```



模块my_cars.py

```python
from car import Car
from electric_car import ElectricCar

my_beetle = Car('volkswagen', 'beetle', 2016)
print(my_beetle.get_descriptive_name())

my_tesla = ElectricCar('tesla', 'roadster', 2016)
print(my_tesla.get_descriptive_name())
```

>输出结果：
>
>2016 Volkswagen Beetle
>2016 Tesla Roadster



### 15 Python 标准库

创建字典并记录其中的键—值对的添加顺序，可使用模块collections中的OrderedDict类。

模块favorite_languages.py

```python
from collections import OrderedDict

favorite_languages = OrderedDict()
	"""调用OrderedDict()来创建一个空的有序字典"""

favorite_languages['jen'] = 'python'
favorite_languages['sarah'] = 'c'
favorite_languages['edward'] = 'ruby'
favorite_languages['phil'] = 'python'

for name, language in favorite_languages.items():
	print(name.title() + "'s favorite language is " +
		language.title() + ".")
```

>输出结果：
>
>Jen's favorite language is Python.
>Sarah's favorite language is C.
>Edward's favorite language is Ruby.
>Phil's favorite language is Python.



### 16 类编码风格

- 类名应采用驼峰命名法，即将类名中的每个单词的首字母都大写，而不使用下划线。
- 实例名和模块名都采用小写格式，并在单词之间加上下划线。
- 对于每个类，都应紧跟在类定义后面包含一个文档字符串。
- 在类中，可使用一个空行来分隔方法；而在模块中，可使用两个空行来分隔类。
- 需要同时导入标准库中的模块和你编写的模块时，先编写导入标准库模块的import语句，再
  添加一个空行，然后编写导入你自己编写的模块的import语句。





