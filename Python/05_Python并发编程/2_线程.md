## 线程

在Python程序中，可以通过threading模块来处理线程。

threading.Thread语法：

```python
Thread(group=None, target=None, name=None, args=(), kwargs={})
```

- target:：要执行的方法；
- name:：线程名；
- args/kwargs:：要传入方法的参数。



### 1 Thread()创建线程

```python
# 创建线程
import threading
import time
def sing():
    for i in range(3):
        print("正在唱歌:{0}".format(i))
        time.sleep(1)
def dance():
    for i in range(3):
        print("正在跳舞:{0}".format(i))
        time.sleep(1)
if __name__=='__main__':
    print("开始")
    t1=threading.Thread(target=sing)    # 创建线程sing
    t2=threading.Thread(target=dance)
    t1.start()      # 启动线程
    t2.start()
    while True:
        length=len(threading.enumerate())   # 查看线程数量
        print("当前运行的线程数为:{0}".format(length))
        if length<=1:
            break
        time.sleep(0.5)
    print("结束")
```



### 2 线程执行代码的封装

```python
# 线程执行代码的封装
import threading
import time
class Mythread(threading.Thread):
    def run(self):      # 重写run方法
        for i in range(3):
            time.sleep(1)
            print("thread_name={0},num={1}".format(self.name,i))
if __name__=='__main__':
    t=Mythread()
    t.start()
```



### 3 线程的执行顺序

```python
# 线程的执行顺序
import threading
import time
class Mythread(threading.Thread):
    def run(self):
        for i in range(3):
            time.sleep(1)
            print("thread_name={0},num={1}".format(self.name,i))

def test():
    for i in range(5):
        t=Mythread()
        t.start()
        t.join()    # 使用join()线程顺序执行

if __name__=='__main__':
    test()
```





### 4 线程间共享全局变量

```python
# 线程间共享全局变量
import threading
import time
num=10
def test1():
    global num
    for i in range(3):
        num+=1
    print("test1 output num:",num)

def test2():
    global num
    for i in range(3):
        num+=1
    print("test2 output num:",num)

if __name__=='__main__':
    t1=threading.Thread(target=test1)
    t2=threading.Thread(target=test2)
    t1.start()
    t1.join()
    t2.start()
    t2.join()
```

>执行结果：
>
>test1 output num: 13
>test2 output num: 16



### 5 线程共享全局变量存在问题

如果多个线程同时对同一个全局变量操作，会出现资源竞争问题，从而数据结果会不正确。

该问题可以通过线程同步来进行解决。

```python
# 线程共享全局变量存在问题
import time
import threading

num=10
def test1():
    global num
    for i in range(100000):
        num+=1
    print("test1 output num:",num)
def test2():
    global num
    for i in range(100000):
        num+=1
    print("test2 output num:",num)

if __name__=='__main__':
    t1=threading.Thread(target=test1)
    t2=threading.Thread(target=test2)
    t1.start()
    t2.start()
    t1.join()
    t2.join()
```

>执行结果：
>
>test1 output num: 100010
>test2 output num: 200010



### 6 互斥锁

- acquire()：上锁
- release()：解锁

```python
# 互斥锁
import time
import threading
num=0
lock=threading.Lock()
def test1():
    global num
    lock.acquire()  #上锁
    for i in range(100000):
        num+=1
    lock.release()  #解锁
    print("test1 output num:",num)

def test2():
    global num
    lock.acquire()  #上锁
    for i in range(100000):
        num+=1
    lock.release()  #解锁
    print("test2 output num:",num)

if __name__=='__main__':
    t1=threading.Thread(target=test1)
    t2=threading.Thread(target=test2)
    t1.start()
    t2.start()
    t1.join()
    t2.join()
```

>执行结果：
>
>test1 output num: 100000
>test2 output num: 200000



```python
# 互斥锁改进
import time
import threading
num=0
lock=threading.Lock()

def test1():
    global num
    for i in range(100000):
        lock.acquire()
        num+=1
        lock.release()
    print("test1 output num:",num)
def test2():
    global num
    for i in range(100000):
        lock.acquire()
        num+=1
        lock.release()
    print("test2 output num:",num)

if __name__=='__main__':
    t1=threading.Thread(target=test1)
    t2=threading.Thread(target=test2)
    t1.start()
    t2.start()
    t1.join()
    t2.join()
```

>执行结果：
>
>test1 output num: 157124
>test2 output num: 200000



### 7 死锁

在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。

```python
# 死锁例子
import threading
import time

class Mythread1(threading.Thread):
    def run(self):
        a.acquire()     # 对a上锁
        print("thread_name={0},up".format(self.name))
        time.sleep(1)
        b.acquire()     # 对b上锁
        print("thread_name={0},down".format(self.name))
        b.release()
        a.release()

class Mythread2(threading.Thread):
    def run(self):
        b.acquire()     # 对b上锁
        print("thread_name={0},up".format(self.name))
        time.sleep(1)
        a.acquire()     # 对a上锁
        print("thread_name={0},down".format(self.name))
        a.release()
        b.release()

a=threading.Lock()
b=threading.Lock()

if __name__=='__main__':
    t1=Mythread1()
    t2=Mythread2()
    t1.start()
    t2.start()
```

