## 进程

在Python3语言中，对多进程支持的是multiprocessing模块和subprocess模块。

multiprocessing.Process语法：

```python
Process（[group [, target [, name [, args [, kwargs]]]]]）
```

- target：表示调用对象。
- args：表示调用对象的位置参数元组。
- kwargs：表示调用对象的字典。



### 1 Process()创建子进程

```python
# Process()创建子进程
import multiprocessing
def run_proc():
    """定义子进程代码"""
    print("子进程运行中")

if __name__=='__main__':
    print("父进程运行")
    p=multiprocessing.Process(target=run_proc)
    print("子进程将要执行")
    p.start()	#启动子进程
```



```python
# 传递参数
import multiprocessing
import time
def run_proc(name,age,**kwargs):
    for i in range(5):
        print("子进程运行中,name={0},age={1},kwargs={2}".format(name,age,kwargs))
        time.sleep(0.5)
if __name__=='__main__':
    print("主进程开始运行")
    p=multiprocessing.Process(target=run_proc,args=('林一',18),kwargs={'林三':16})
    print("子进程将要执行")
    p.start()
```



### 2 join()等待子进程结束

```python
# join()等待子进程结束
import multiprocessing
import time
def worker(interval):
    print("work start")
    time.sleep(interval)
    print("work end")
if __name__=='__main__':
    p=multiprocessing.Process(target=worker,args=(3,))
    p.start()
    p.join()    #等待进程p终止
    print("主进程结束")
```

```python
# 设置等待超时时间
import multiprocessing
import time
def worker(interval):
    print("work start")
    time.sleep(interval)
    print("work end")
if __name__=='__main__':
    p=multiprocessing.Process(target=worker,args=(5,))
    p.start()
    p.join(3)    #等待进程p终止,超时为3s
    print("主进程结束")
```



### 3 Process属性

| 方法 | 描述             |
| ---- | ---------------- |
| name | 进程的名称       |
| pid  | 进程的整数进程ID |

```python
# Process属性
import multiprocessing
import time
def clock(interval):
    for i in range(5):
        print("当前时间为：{0}".format(time.ctime()))
        time.sleep(interval)
if __name__=='__main__':
    p=multiprocessing.Process(target=clock,args=(1,))
    p.start()
    p.join()
    print("pidname={0},pid={1}".format(p.name,p.pid))
    print("进程是否运行:{0}".format(p.is_alive()))
```



### 4 多个子进程

```python
# 多个子进程
import multiprocessing
import time
def work1(interval):
    print("work1 start")
    time.sleep(interval)
    print("work1 end")

def work2(interval):
    print("work2 start")
    time.sleep(interval)
    print("work2 end")

def work3(interval):
    print("work3 start")
    time.sleep(interval)
    print("work3 end")

if __name__=='__main__':
    p1=multiprocessing.Process(target=work1,args=(4,))
    p2 = multiprocessing.Process(target=work2, args=(3,))
    p3 = multiprocessing.Process(target=work3, args=(2,))
    p1.start()
    p2.start()
    p3.start()
    p1.join()
    p2.join()
    p3.join()
    print("主进程结束")
```



### 5 Process子类

```python
# 继承Process的类，重写run()方法创建进程
import multiprocessing
import time
class ClockProcess(multiprocessing.Process):
    def __init__(self,interval):
        multiprocessing.Process.__init__(self)
        self.interval=interval
    def run(self):
        print("子进程开始执行的时间:{0}".format(time.time()))
        time.sleep(self.interval)
        print("子进程结束的时间:{0}".format(time.time()))
if __name__=='__main__':
    p=ClockProcess(2)
    p.start()
    p.join()
    print("主进程结束")
```



### 6 Pool()进程池

```python
# apply_async()进程池的使用（非阻塞）
import multiprocessing
import time
def func(msg):
    print("start:",msg)
    time.sleep(3)
    print("end:",msg)
if __name__=='__main__':
    pool=multiprocessing.Pool(3)
    for i in range(5):
        msg="hello {0}".format(i)
        pool.apply_async(func,(msg,))
    pool.close()
    pool.join()
    print("主程序执行完成")
```

>执行结果：
>
>start: hello 0
>start: hello 1
>start: hello 2
>end: hello 0
>start: hello 3
>end: hello 1
>start: hello 4
>end: hello 2
>end: hello 3
>end: hello 4
>主程序执行完成



```python
# apply()使用进程池（阻塞）
import multiprocessing
import time
def func(msg):
    print("start:",msg)
    time.sleep(3)
    print("end:",msg)
if __name__=='__main__':
    pool=multiprocessing.Pool(3)
    for i in range(5):
        msg="hello {0}".format(i)
        pool.apply(func,(msg,))
    pool.close()
    pool.join()
    print("主程序执行完成")
```

>执行结果：
>
>start: hello 0
>end: hello 0
>start: hello 1
>end: hello 1
>start: hello 2
>end: hello 2
>start: hello 3
>end: hello 3
>start: hello 4
>end: hello 4
>主程序执行完成



### 7 Queue()进程间通讯

Queue实现多进程之间的数据传递，Queue本身是一个消息列队程序。

| Queue方法 | 描述                              |
| --------- | --------------------------------- |
| put()     | 写入消息                          |
| get()     | 读取消息                          |
| full()    | 如果队列满了，返回True,反之False  |
| empty()   | 如果队列为空，返回True，反之False |
| qsize()   | 返回当前队列包含的消息数量        |



```python
# Queue消息列队
import multiprocessing
q=multiprocessing.Queue(3)      # 初始化一个Queue对象，最多可接收三条put消息
q.put("消息1")
q.put("消息2")
print("消息队列是否已满:",q.full())
q.put("消息3")
print("消息队列是否已满",q.full())
if not q.empty():
    for i in range(q.qsize()):
        print(q.get())
```

>执行结果：
>
>消息队列是否已满: False
>消息队列是否已满 True
>消息1
>消息2
>消息3



```python
# Queue实现多进程之间的数据传递
# 创建两个子进程，一个往Queue里写数据，一个从Queue里读数据
import multiprocessing
import time

def write(q):
    """将列表中的元素写入队列中"""
    for i in ['a','b','c']:
        print("开始写入值:",i)
        q.put(i)
        time.sleep(1)
        
def read(q):
    """读取队列信息"""
    print("开始读取")
    while True:
        if not q.empty():
            print("读取到:",q.get())
            time.sleep(1)
        else:
            break
            
if __name__=='__main__':
    q=multiprocessing.Queue()
    pw=multiprocessing.Process(target=write,args=(q,))	# 创建写子进程
    pr=multiprocessing.Process(target=read,args=(q,))	# 创建读子进程
    pw.start()
    pw.join()
    pr.start()
    pr.join()
```

>执行结果：
>
>开始写入值: a
>开始写入值: b
>开始写入值: c
>开始读取
>读取到: a
>读取到: b
>读取到: c





