

### 1 线程

在Python程序中，可以通过threading模块来处理线程。

threading.Thread语法：

```python
Thread(group=None, target=None, name=None, args=(), kwargs={})
```

- target:：要执行的方法；
- name:：线程名；
- args/kwargs:：要传入方法的参数。



#### 1.1 Thread()创建线程

```python
# 创建线程
import threading
import time
def sing():
    for i in range(3):
        print("正在唱歌:{0}".format(i))
        time.sleep(1)
def dance():
    for i in range(3):
        print("正在跳舞:{0}".format(i))
        time.sleep(1)
if __name__=='__main__':
    print("开始")
    t1=threading.Thread(target=sing)    # 创建线程sing
    t2=threading.Thread(target=dance)
    t1.start()      # 启动线程
    t2.start()
    while True:
        length=len(threading.enumerate())   # 查看线程数量
        print("当前运行的线程数为:{0}".format(length))
        if length<=1:
            break
        time.sleep(0.5)
    print("结束")
```



#### 1.2 线程执行代码的封装

```python
# 线程执行代码的封装
import threading
import time
class Mythread(threading.Thread):
    def run(self):      # 重写run方法
        for i in range(3):
            time.sleep(1)
            print("thread_name={0},num={1}".format(self.name,i))
if __name__=='__main__':
    t=Mythread()
    t.start()
```



#### 1.3 线程的执行顺序

```python
# 线程的执行顺序
import threading
import time
class Mythread(threading.Thread):
    def run(self):
        for i in range(3):
            time.sleep(1)
            print("thread_name={0},num={1}".format(self.name,i))

def test():
    for i in range(5):
        t=Mythread()
        t.start()
        t.join()    # 使用join()线程顺序执行

if __name__=='__main__':
    test()
```





#### 1.4 线程间共享全局变量

```python
# 线程间共享全局变量
import threading
import time
num=10
def test1():
    global num
    for i in range(3):
        num+=1
    print("test1 output num:",num)

def test2():
    global num
    for i in range(3):
        num+=1
    print("test2 output num:",num)

if __name__=='__main__':
    t1=threading.Thread(target=test1)
    t2=threading.Thread(target=test2)
    t1.start()
    t1.join()
    t2.start()
    t2.join()
```

>执行结果：
>
>test1 output num: 13
>test2 output num: 16



#### 1.5 线程共享全局变量存在问题

如果多个线程同时对同一个全局变量操作，会出现资源竞争问题，从而数据结果会不正确。

该问题可以通过线程同步来进行解决。

```python
# 线程共享全局变量存在问题
import time
import threading

num=10
def test1():
    global num
    for i in range(100000):
        num+=1
    print("test1 output num:",num)
def test2():
    global num
    for i in range(100000):
        num+=1
    print("test2 output num:",num)

if __name__=='__main__':
    t1=threading.Thread(target=test1)
    t2=threading.Thread(target=test2)
    t1.start()
    t2.start()
    t1.join()
    t2.join()
```

>执行结果：
>
>test1 output num: 100010
>test2 output num: 200010



#### 1.6 互斥锁

- acquire()：上锁
- release()：解锁

```python
# 互斥锁
import time
import threading
num=0
lock=threading.Lock()
def test1():
    global num
    lock.acquire()  #上锁
    for i in range(100000):
        num+=1
    lock.release()  #解锁
    print("test1 output num:",num)

def test2():
    global num
    lock.acquire()  #上锁
    for i in range(100000):
        num+=1
    lock.release()  #解锁
    print("test2 output num:",num)

if __name__=='__main__':
    t1=threading.Thread(target=test1)
    t2=threading.Thread(target=test2)
    t1.start()
    t2.start()
    t1.join()
    t2.join()
```

>执行结果：
>
>test1 output num: 100000
>test2 output num: 200000



```python
# 互斥锁改进
import time
import threading
num=0
lock=threading.Lock()

def test1():
    global num
    for i in range(100000):
        lock.acquire()
        num+=1
        lock.release()
    print("test1 output num:",num)
def test2():
    global num
    for i in range(100000):
        lock.acquire()
        num+=1
        lock.release()
    print("test2 output num:",num)

if __name__=='__main__':
    t1=threading.Thread(target=test1)
    t2=threading.Thread(target=test2)
    t1.start()
    t2.start()
    t1.join()
    t2.join()
```

>执行结果：
>
>test1 output num: 157124
>test2 output num: 200000



#### 1.7 死锁

在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。

```python
# 死锁例子
import threading
import time

class Mythread1(threading.Thread):
    def run(self):
        a.acquire()     # 对a上锁
        print("thread_name={0},up".format(self.name))
        time.sleep(1)
        b.acquire()     # 对b上锁
        print("thread_name={0},down".format(self.name))
        b.release()
        a.release()

class Mythread2(threading.Thread):
    def run(self):
        b.acquire()     # 对b上锁
        print("thread_name={0},up".format(self.name))
        time.sleep(1)
        a.acquire()     # 对a上锁
        print("thread_name={0},down".format(self.name))
        a.release()
        b.release()

a=threading.Lock()
b=threading.Lock()

if __name__=='__main__':
    t1=Mythread1()
    t2=Mythread2()
    t1.start()
    t2.start()
```



### 2 进程

在Python3语言中，对多进程支持的是multiprocessing模块和subprocess模块。

multiprocessing.Process语法：

```python
Process（[group [, target [, name [, args [, kwargs]]]]]）
```

- target：表示调用对象。
- args：表示调用对象的位置参数元组。
- kwargs：表示调用对象的字典。



#### 2.1 Process()创建子进程

```python
# Process()创建子进程
import multiprocessing
def run_proc():
    """定义子进程代码"""
    print("子进程运行中")

if __name__=='__main__':
    print("父进程运行")
    p=multiprocessing.Process(target=run_proc)
    print("子进程将要执行")
    p.start()	#启动子进程
```



```python
# 传递参数
import multiprocessing
import time
def run_proc(name,age,**kwargs):
    for i in range(5):
        print("子进程运行中,name={0},age={1},kwargs={2}".format(name,age,kwargs))
        time.sleep(0.5)
if __name__=='__main__':
    print("主进程开始运行")
    p=multiprocessing.Process(target=run_proc,args=('林一',18),kwargs={'林三':16})
    print("子进程将要执行")
    p.start()
```



#### 2.2 join()等待子进程结束

```python
# join()等待子进程结束
import multiprocessing
import time
def worker(interval):
    print("work start")
    time.sleep(interval)
    print("work end")
if __name__=='__main__':
    p=multiprocessing.Process(target=worker,args=(3,))
    p.start()
    p.join()    #等待进程p终止
    print("主进程结束")
```

```python
# 设置等待超时时间
import multiprocessing
import time
def worker(interval):
    print("work start")
    time.sleep(interval)
    print("work end")
if __name__=='__main__':
    p=multiprocessing.Process(target=worker,args=(5,))
    p.start()
    p.join(3)    #等待进程p终止,超时为3s
    print("主进程结束")
```



#### 2.3 Process属性

| 方法 | 描述             |
| ---- | ---------------- |
| name | 进程的名称       |
| pid  | 进程的整数进程ID |

```python
# Process属性
import multiprocessing
import time
def clock(interval):
    for i in range(5):
        print("当前时间为：{0}".format(time.ctime()))
        time.sleep(interval)
if __name__=='__main__':
    p=multiprocessing.Process(target=clock,args=(1,))
    p.start()
    p.join()
    print("pidname={0},pid={1}".format(p.name,p.pid))
    print("进程是否运行:{0}".format(p.is_alive()))
```



#### 2.4 多个子进程

```python
# 多个子进程
import multiprocessing
import time
def work1(interval):
    print("work1 start")
    time.sleep(interval)
    print("work1 end")

def work2(interval):
    print("work2 start")
    time.sleep(interval)
    print("work2 end")

def work3(interval):
    print("work3 start")
    time.sleep(interval)
    print("work3 end")

if __name__=='__main__':
    p1=multiprocessing.Process(target=work1,args=(4,))
    p2 = multiprocessing.Process(target=work2, args=(3,))
    p3 = multiprocessing.Process(target=work3, args=(2,))
    p1.start()
    p2.start()
    p3.start()
    p1.join()
    p2.join()
    p3.join()
    print("主进程结束")
```



#### 2.5 Process子类

```python
# 继承Process的类，重写run()方法创建进程
import multiprocessing
import time
class ClockProcess(multiprocessing.Process):
    def __init__(self,interval):
        multiprocessing.Process.__init__(self)
        self.interval=interval
    def run(self):
        print("子进程开始执行的时间:{0}".format(time.time()))
        time.sleep(self.interval)
        print("子进程结束的时间:{0}".format(time.time()))
if __name__=='__main__':
    p=ClockProcess(2)
    p.start()
    p.join()
    print("主进程结束")
```



#### 2.6 Pool()进程池

```python
# apply_async()进程池的使用（非阻塞）
import multiprocessing
import time
def func(msg):
    print("start:",msg)
    time.sleep(3)
    print("end:",msg)
if __name__=='__main__':
    pool=multiprocessing.Pool(3)
    for i in range(5):
        msg="hello {0}".format(i)
        pool.apply_async(func,(msg,))
    pool.close()
    pool.join()
    print("主程序执行完成")
```

>执行结果：
>
>start: hello 0
>start: hello 1
>start: hello 2
>end: hello 0
>start: hello 3
>end: hello 1
>start: hello 4
>end: hello 2
>end: hello 3
>end: hello 4
>主程序执行完成



```python
# apply()使用进程池（阻塞）
import multiprocessing
import time
def func(msg):
    print("start:",msg)
    time.sleep(3)
    print("end:",msg)
if __name__=='__main__':
    pool=multiprocessing.Pool(3)
    for i in range(5):
        msg="hello {0}".format(i)
        pool.apply(func,(msg,))
    pool.close()
    pool.join()
    print("主程序执行完成")
```

>执行结果：
>
>start: hello 0
>end: hello 0
>start: hello 1
>end: hello 1
>start: hello 2
>end: hello 2
>start: hello 3
>end: hello 3
>start: hello 4
>end: hello 4
>主程序执行完成



#### 2.7 Queue()进程间通讯

Queue实现多进程之间的数据传递，Queue本身是一个消息列队程序。

| Queue方法 | 描述                              |
| --------- | --------------------------------- |
| put()     | 写入消息                          |
| get()     | 读取消息                          |
| full()    | 如果队列满了，返回True,反之False  |
| empty()   | 如果队列为空，返回True，反之False |
| qsize()   | 返回当前队列包含的消息数量        |



```python
# Queue消息列队
import multiprocessing
q=multiprocessing.Queue(3)      # 初始化一个Queue对象，最多可接收三条put消息
q.put("消息1")
q.put("消息2")
print("消息队列是否已满:",q.full())
q.put("消息3")
print("消息队列是否已满",q.full())
if not q.empty():
    for i in range(q.qsize()):
        print(q.get())
```

>执行结果：
>
>消息队列是否已满: False
>消息队列是否已满 True
>消息1
>消息2
>消息3



```python
# Queue实现多进程之间的数据传递
# 创建两个子进程，一个往Queue里写数据，一个从Queue里读数据
import multiprocessing
import time

def write(q):
    """将列表中的元素写入队列中"""
    for i in ['a','b','c']:
        print("开始写入值:",i)
        q.put(i)
        time.sleep(1)
        
def read(q):
    """读取队列信息"""
    print("开始读取")
    while True:
        if not q.empty():
            print("读取到:",q.get())
            time.sleep(1)
        else:
            break
            
if __name__=='__main__':
    q=multiprocessing.Queue()
    pw=multiprocessing.Process(target=write,args=(q,))	# 创建写子进程
    pr=multiprocessing.Process(target=read,args=(q,))	# 创建读子进程
    pw.start()
    pw.join()
    pr.start()
    pr.join()
```

>执行结果：
>
>开始写入值: a
>开始写入值: b
>开始写入值: c
>开始读取
>读取到: a
>读取到: b
>读取到: c





### 3 迭代器

Iterator

迭代器是一个可以记住遍历的位置的对象。

迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。

迭代器只能往前不会后退。

#### 3.1 可迭代对象

可以通过for...in...这类语句迭代读取一条数据供我们使用的对象称之为可迭代对象（Iterable）。

可以使用 isinstance() 判断一个对象是否是 Iterable 对象

```python
from collections import Iterable
print(isinstance([],Iterable))
print(isinstance({},Iterable))
print(isinstance('abc',Iterable))
print(isinstance(100,Iterable))
```

>执行结果：
>
>True
>True
>True
>False



#### 3.2 迭代器

可迭代对象通过`__iter__`方法向我们提供一个迭代器。

我们在迭代一个可迭代对象的时候，实际上就是先获取该对象提供的一个迭代器，然后通过这个迭代器来依次获取对象中的每一个数据。

一个具备了`__iter__`方法的对象，就是一个可迭代对象。

```python
from collections import Iterable
class Mylist(object):
    def __init__(self):
        self.container=[]
    def add(self,item):
        self.container.append(item)
    def __iter__(self):
        pass
mylist=Mylist()
print(isinstance(mylist,Iterable))
```



#### 3.3 iter()与next()函数

list、tuple等都是可迭代对象，我们可以通过iter()函数获取这些可迭代对象的迭代器。

对获取到的迭代器不断使用next()函数来获取下一条数据。

iter()函数实际上就是调用了可迭代对象的`__iter__`方法。

```python
>>> a=[11,22,33,44,55]
>>> b=iter(a)
>>> next(b)
11
>>> next(b)
22
>>> next(b)
33
>>> next(b)
44
>>> next(b)
55
>>> next(b)
Traceback (most recent call last):
  File "<pyshell#9>", line 1, in <module>
    next(b)
StopIteration
>>> 
```

当已经迭代完最后一个数据之后，再次调用next()函数会抛出StopIteration的异常，表示所有数据都已迭代完成，不用再执行next()函数了。



#### 3.4 迭代器Iterator

一个实现了`__iter__`方法和`__next__`方法的对象，就是迭代器。



#### 3.5 for...in...循环的本质

for **item** in **Iterable** 循环的本质就是先通过iter()函数获取可迭代对象Iterable的迭代器，然后对获取到的迭代器不断调用next()方法来获取下一个值并将其赋值给item，当遇到StopIteration的异常后循环结束。



```python
# 迭代器的应用场景
class Fi(object):
    """斐波那契数列迭代器"""
    def __init__(self,n):
        self.n=n
        self.current=0  # current用来保存当前生成到数列中的第几个数了
        self.num1=0     # num1用来保存前前一个数
        self.num2=1     # num2用来保存前一个数
    def __next__(self):
        if self.current<self.n:
            num=self.num1
            self.num1,self.num2=self.num2,self.num1+self.num2
            self.current+=1
            return num
        else:
            raise StopIteration
    def __iter__(self):
        return self

if __name__=='__main__':
    a=Fi(10)
    for num in a:
        print(num,end=" ")
```

>执行结果：
>0 1 1 2 3 5 8 13 21 34



### 4 生成器

generator

生成器是一类特殊的迭代器。



#### 4.1 创建生成器方法1

```python
a = ( x*2 for x in range(5))
print(a)
```

>执行结果：
>
><generator object <genexpr> at 0x0000026826B6C2E0>



#### 4.2 创建生成器方法2

只要在def中有yield关键字的 就称为 生成器。

```python
# 斐波那契数列
def fi(n):
    current=0
    num1,num2=0,1
    while current<n:
        num=num1
        num1,num2=num2,num1+num2
        current+=1
        yield num
    return 'done'

for n in fi(10):
    print(n)
```

