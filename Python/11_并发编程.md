## 并发编程

### 1 进程

在Python3语言中，对多进程支持的是multiprocessing模块和subprocess模块。

multiprocessing.Process语法：

```python
Process（[group [, target [, name [, args [, kwargs]]]]]）
```

| Process方法       | 描述                                                         |
| ----------------- | ------------------------------------------------------------ |
| is_alive()        | 如果p仍然运行，返回True                                      |
| join（[timeout]） | 等待进程p终止。Timeout是可选的超时期限，进程可以被链接无数次，但如果连接自身则会出错 |
| run()             | 进程启动时运行的方法。默认情况下，会调用传递给Process构造函数的target。定义进程的另一种方法是继承Process类并重新实现run()函数 |
| start()           | 启动进程，这将运行代表进程的子进程，并调用该子进程中的run()函数 |
| terminate()       | 强制终止进程。如果调用此函数，进程p将被立即终止，同时不会进行任何清理动作。如果进程p创建了它自己的子进程，这些进程将变为僵尸进程。使用此方法时需要特别小心。如果p保存了一个锁或参与了进程间通信，那么终止它可能会导致死锁或I/O损坏 |



#### 1.1 创建子进程

```python
import multiprocessing
def run_proc():
    """定义子进程代码"""
    print("子进程运行中")

if __name__=='__main__':
    print("父进程运行")
    p=multiprocessing.Process(target=run_proc)
    print("子进程将要执行")
    p.start()
```



#### 1.2 传递参数

```python
import multiprocessing
import time
def run_proc(name,age,**kwargs):
    for i in range(5):
        print("子进程运行中,name={0},age={1},kwargs={2}".format(name,age,kwargs))
        time.sleep(0.5)
if __name__=='__main__':
    print("主进程开始运行")
    p=multiprocessing.Process(target=run_proc,args=('林一',18),kwargs={'林三':16})
    print("子进程将要执行")
    p.start()
```



#### 1.3 join()方法

```python
import multiprocessing
import time
def worker(interval):
    print("work start")
    time.sleep(interval)
    print("work end")
if __name__=='__main__':
    p=multiprocessing.Process(target=worker,args=(3,))
    p.start()
    p.join()    #等待进程p终止
    print("主进程结束")
```

```python
import multiprocessing
import time
def worker(interval):
    print("work start")
    time.sleep(interval)
    print("work end")
if __name__=='__main__':
    p=multiprocessing.Process(target=worker,args=(5,))
    p.start()
    p.join(3)    #等待进程p终止,超时为3s
    print("主进程结束")
```



#### 1.4 Process属性

| 方法 | 描述             |
| ---- | ---------------- |
| name | 进程的名称       |
| pid  | 进程的整数进程ID |

```python
import multiprocessing
import time
def clock(interval):
    for i in range(5):
        print("当前时间为：{0}".format(time.ctime()))
        time.sleep(interval)
if __name__=='__main__':
    p=multiprocessing.Process(target=clock,args=(1,))
    p.start()
    p.join()
    print("pidname={0},pid={1}".format(p.name,p.pid))
    print("进程是否运行:{0}".format(p.is_alive()))
```



#### 1.5 多个子进程

```python
import multiprocessing
import time
def work1(interval):
    print("work1 start")
    time.sleep(interval)
    print("work1 end")

def work2(interval):
    print("work2 start")
    time.sleep(interval)
    print("work2 end")

def work3(interval):
    print("work3 start")
    time.sleep(interval)
    print("work3 end")

if __name__=='__main__':
    p1=multiprocessing.Process(target=work1,args=(4,))
    p2 = multiprocessing.Process(target=work2, args=(3,))
    p3 = multiprocessing.Process(target=work3, args=(2,))
    p1.start()
    p2.start()
    p3.start()
    p1.join()
    p2.join()
    p3.join()
    print("主进程结束")
```



#### 1.6 Process子类

```python
# 继承Process的类，重写run()方法创建进程
import multiprocessing
import time
class ClockProcess(multiprocessing.Process):
    def __init__(self,interval):
        multiprocessing.Process.__init__(self)
        self.interval=interval
    def run(self):
        print("子进程开始执行的时间:{0}".format(time.time()))
        time.sleep(self.interval)
        print("子进程结束的时间:{0}".format(time.time()))
if __name__=='__main__':
    p=ClockProcess(2)
    p.start()
    p.join()
    print("主进程结束")
```



#### 1.7 Pool进程池

语法：

```python
Pool（[numprocess [, initializer [, initargs]]]）
```

```python
# 进程池的使用（非阻塞）
import multiprocessing
import time
def func(msg):
    print("start:",msg)
    time.sleep(3)
    print("end:",msg)
if __name__=='__main__':
    pool=multiprocessing.Pool(3)
    for i in range(5):
        msg="hello {0}".format(i)
        pool.apply_async(func,(msg,))
    pool.close()
    pool.join()
    print("主程序执行完成")
```

>执行结果：
>
>start: hello 0
>start: hello 1
>start: hello 2
>end: hello 0
>start: hello 3
>end: hello 1
>start: hello 4
>end: hello 2
>end: hello 3
>end: hello 4
>主程序执行完成



```python
# 使用进程池（阻塞）
import multiprocessing
import time
def func(msg):
    print("start:",msg)
    time.sleep(3)
    print("end:",msg)
if __name__=='__main__':
    pool=multiprocessing.Pool(3)
    for i in range(5):
        msg="hello {0}".format(i)
        pool.apply(func,(msg,))
    pool.close()
    pool.join()
    print("主程序执行完成")
```

>执行结果：
>
>start: hello 0
>end: hello 0
>start: hello 1
>end: hello 1
>start: hello 2
>end: hello 2
>start: hello 3
>end: hello 3
>start: hello 4
>end: hello 4
>主程序执行完成



#### 1.8 进程间通讯

全局变量在多个进程中不共享，进程之间的数据是独立的。

```python
# 全局变量在多个进程中不共享
import multiprocessing
num=1
def work1():
    global num
    num+=5
    print("work1 start,num={0}".format(num))

def work2():
    global num
    num+=10
    print("work2 start,num={0}".format(num))

if __name__=='__main__':
    print("父进程开始运行")
    p1=multiprocessing.Process(target=work1)
    p2=multiprocessing.Process(target=work2)
    p1.start()
    p2.start()
    p1.join()
    p2.join()
```

>执行结果：
>
>父进程开始运行
>work1 start,num=6
>work2 start,num=11



Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。

| Queue方法 | 描述                   |
| --------- | ---------------------- |
| put()     | 写入消息               |
| get()     | 读取消息               |
| full()    | queue已满，返回True    |
| empty()   | queue为空，返回True    |
| qsize()   | 返回目前队列中项的数量 |



```python
# Queue的方法使用
import multiprocessing
q=multiprocessing.Queue(3)
q.put("消息1")
q.put("消息2")
print("消息队列是否已满:",q.full())
q.put("消息3")
print("消息队列是否已满:",q.full())
if not q.full():
    q.put("消息4")
if not q.empty():
    for i in range(q.qsize()):
        print(q.get())
```

>执行结果：
>
>消息队列是否已满: False
>消息队列是否已满: True
>消息1
>消息2
>消息3



```python
# Queue创建进程完成进程间通信
import multiprocessing
import time
def write(q):
    """将列表中的元素写入队列中"""
    for i in ['a','b','c']:
        print("开始写入值:",i)
        q.put(i)
        time.sleep(1)
def read(q):
    """读取队列信息"""
    print("开始读取")
    while True:
        if not q.empty():
            print("读取到:",q.get())
            time.sleep(1)
        else:
            break
if __name__=='__main__':
    q=multiprocessing.Queue()
    pw=multiprocessing.Process(target=write,args=(q,))
    pr=multiprocessing.Process(target=read,args=(q,))
    pw.start()
    pw.join()
    pr.start()
    pr.join()
```

>执行结果：
>
>开始写入值: a
>开始写入值: b
>开始写入值: c
>开始读取
>读取到: a
>读取到: b
>读取到: c



```python
# pool创建进程完成进程间通信
import multiprocessing
import time
def write(q):
    """将列表中的元素写入队列中"""
    for i in ['a','b','c']:
        print("开始写入值:",i)
        q.put(i)
        time.sleep(1)
def read(q):
    """读取队列信息"""
    print("开始读取")
    while True:
        if not q.empty():
            print("读取到:",q.get())
            time.sleep(1)
        else:
            break
if __name__=='__main__':
    q=multiprocessing.Manager().Queue()
    p=multiprocessing.Pool(3)
    p.apply(write,(q,))
    p.apply(read,(q,))
    p.close()
    p.join()
```



### 2 线程

在Python程序中，可以通过threading模块来处理线程。

threading.Thread语法：

```python
Thread(group=None, target=None, name=None, args=(), kwargs={})
```

#### 2.1 创建线程

```python
# threading.Thread 创建线程
import threading
import time
def fun1(thread_name,delay):
    print("fun1,thread_name={0},start".format(thread_name))
    time.sleep(delay)
    print("fun1,thread_name={0},end".format(thread_name))

def fun2(thread_name,delay):
    print("fun2,thread_name={0},start".format(thread_name))
    time.sleep(delay)
    print("fun2,thread_name={0},end".format(thread_name))
if __name__=='__main__':
    print("start running")
    t1=threading.Thread(target=fun1,args=('thread-1',2))
    t2=threading.Thread(target=fun2,args=('thread-2',4))
    t1.start()
    t2.start()
```



```python
# 继承threading.Thread类创建线程
import threading
import time
def fun1(thread_name,delay):
    print("fun1,thread_name={0},start".format(thread_name))
    time.sleep(delay)
    print("fun1,thread_name={0},end".format(thread_name))

def fun2(thread_name,delay):
    print("fun2,thread_name={0},start".format(thread_name))
    time.sleep(delay)
    print("fun2,thread_name={0},end".format(thread_name))

class MyThread(threading.Thread):
    def __init__(self,func,name,args):
        super().__init__(target=func,name=name,args=args)
    def run(self):
        self._target(*self._args)

if __name__=='__main__':
    print("start running")
    t1=MyThread(fun1,'thread-1',(2,))
    t2=MyThread(fun2,'thread-2',(4,))
    t1.start()
    t2.start()
```













