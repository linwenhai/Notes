## 面向对象

### 1 面向对象和面向过程区别

面向过程：关注的是“程序的逻辑流程”，是一种“执行者”思维，适合编写小规模的程序。

面向对象：关注的是“软件中对象之间的关系”，是一种“设计者”思维，适合编写大规模的程序。



### 2 定义类

![img](D:\Notes\Python\image\20200923201648195.png)

![img](D:\Notes\Python\image\20200923201711717.png)

```python
class Student:
    """定义类例子"""
    def __init__(self,name,score):  #构造方法
        self.name=name      #实例属性
        self.score=score
 
    def say_score(self):    #实例方法
        print("{0}分数是:{1}".format(self.name,self.score))
 
s1=Student('林一',90)     #s1实例对象
s1.say_score()
```



### 3 `__init__`与`__new__`方法

Python对象包含：

- id（identify识别码）
- type（对象类型）
- value（对象的值：属性和方法）

`__init__()`方法：构造函数，用于执行实例对象的初始化工作，即对象创建后，初始化当前对象的相关属性，无返回值。

- 第一个参数为self，self指创建好的实例对象。
- 通过类名()调用构造函数，返回创建的对象给变量。
- 初始化指的是给实例属性赋值。



### 4 实例属性和方法

实例属性：从属于实例对象的属性，也称为实例对象。

- 定义：self.实例属性名=初始值
- 方法内调用：self.实例属性名
- 实例对象调用：对象变量.实例属性名

实例方法：从属于实例对象的方法。

- 定义方法时，第一个参数是self，调用方法无需传参给self



### 5 类对象、类属性、类方法与静态方法

类对象：<class 'type'>

类属性：从属于“类对象”的属性，可被所有实例对象共享，调用 类名.类变量名。

类方法：从属与类对象的方法，调用 类名.类方法名。

静态方法：与类对象无关的方法。

```python
class 类名：
    类变量名= 初始值
```

```python
# 类方法
class 类名:
    @classmethod
    def 类方法名(cls [，形参列表]) ：    # cls 指的就是“类对象”本身
        pass
```

```python
# 静态方法
class 类名:
    @staticmethod
    def 静态方法名([形参列表]) ：
        pass
```



### 6 实例对象和类对象创建过程

```python
# 实例对象和类对象创建例子
class Student:
    company="尚学堂"   #类属性
    count=0
 
    def __init__(self,name,score):
        self.name=name      #实例属性
        self.score=score
        Student.count+=1
 
    def say_score(self):    #实例方法
        print(Student.company)
        print(self.name,self.score)
 
s1=Student('高淇',80)     #实例对象
s1.say_score()
print(Student.count)
```

![img](D:\Notes\Python\image\20200923211704599.png)



### 7 `__del__`方法与垃圾回收机制

__del__()方法：称为析构方法，用于实现对象被销毁时所需的操作。

Python 实现自动的垃圾回收，当对象没有被引用时（引用计数为 0），由垃圾回收器调用__del__方法。

 

### 8 `__call__`方法

__call__方法：定义了__call__方法的对象，称为“可调用对象”，即该对象可以像函数一样被调用。

```python
class SalaryAccount:
    """工资计算类"""
    def __call__(self,salary):
        yearSalary=salary*12
        daySalary=salary//30
        hourSalary=daySalary//8
        return dict(yearSalary=yearSalary,monthSalary=salary,daySalary=daySalary,hourSalary=hourSalary)
 
s=SalaryAccount()
print(s(28000))
```



### 9 私有属性和私有方法

私有属性和私有方法要点：

- 两个下划线开头的属性是私有的(private)，其他为公共的(public)。
- 类内部可以访问私有属性(方法)。
- 类外部不能直接访问私有属性(方法)。
- 类外部可以通过“_类名__私有属性(方法)名”访问私有属性(方法)。

```python
#私有属性和公有属性使用测试
class Employee:
    __company="深蓝"         #私有类属性
    def __init__(self,name,age):
        self.name=name
        self.__age=age      #私有实例属性
    def say_company(self):
        print(Employee.__company)   #类内部可以直接访问私有属性
        print(self.name,self.__age)
        self.__work()
    def __work(self):       #私有实例方法
        print("努力工作")
 
p1=Employee("林一",18)
print(p1._Employee__age)    #访问私有属性
```



### 10 @property 装饰器

@property ：将一个方法的调用方式变成“属性调用”。

```python
#测试@property
class Employee:
    def __init__(self,name,salary):
        self.name=name
        self.__salary=salary
 
    @property
    def salary(self):       #相当于 salary 属性的 getter 方法
        print(self.__salary)
        return self.__salary
 
    @salary.setter
    def salary(self,salary):    #相当于 salary 属性的 setter 方法
        if(0<salary<1000000):
            self.__salary=salary
        else:
            print("薪水录入异常")
 
emp1=Employee("林一",100000)
print(emp1.salary)
```



### 11 封装（隐藏）

隐藏对象的属性和实现细节，只对外提供必要的方法。

通过“私有属性、私有方法”的方式，实现“封装”。



### 12 继承

如个新类继承自一个设计好的类，就直接具备了已有类的特征，已有的类，我们称为“父类或者基类”，新的类，我们称为“子类或者派生类”。

- 在类定义中没有指定父类，则默认父类是 object 类。
- 定义子类时，必须在其构造函数中调用父类的构造函数，格式：父类名.__init__(self, 参数列表)。
- 子类继承了父类除构造方法之外的所有成员。
- 子类可以重新定义父类中的方法。

```python
# 继承例子
class Person:
    def __init__(self,name,age):
        self.name=name
        self.__age=age
    def say_age(self):
        print(self.name,self.__age)
 
class Student(Person):
    def __init__(self,name,age,score):
        Person.__init__(self,name,age)  # 调用父类的构造函数
        self.score=score
 
s1=Student("林一",18,98)
s1.say_age()
```



#### 12.1 重写父类方法

```python
# 重写父类方法
class Person:
    def __init__(self,name,age):
        self.name=name
        self.age=age
    def say_age(self):
        print(self.age)
    def say_name(self):
        print(self.name)
 
class Student(Person):
    def __init__(self,name,age,score):
        Person.__init__(self,name,age)  #调用父类构造函数
        self.score=score
    def say_score(self):
        print(self.score)
    def say_name(self):     #重写父类方法
        print("我是谁")
 
s1=Student("林一",18,98)
s1.say_age()
s1.say_score()
s1.say_name()
```



#### 12.2 mro()方法 

mro()方法：方法解析顺序，获得“类的层次结构”。

object 类：是所有类的父类，所有的类都有 object 类的属性和方法

```python
#查看类的继承层次结构
class A:pass
class B(A):pass
class C(B):pass
print(C.mro())      #mro()方法输出这个类的继承层次结构
```



#### 12.3 dir()方法

dir()方法：查看对象属性。

```python
#dir()查看对象属性
class Person:
    def __init__(self,name,age):
        self.name=name
        self.age=age
    def say_age(self):
        print(self.age)
 
a=object()
print(dir())
b=Person("林一",18)
print(dir(b))
```



#### 12.4 `__str__`()方法

`__str__`()方法：用于返回一个对于“对象的描述”。

```python
#重写__str__()方法
class Person:
    def __init__(self,name,age):
        self.name=name
        self.age=age
    def __str__(self):
        return "{0}的年龄是:{1}".format(self.name,self.age)
 
p=Person("林一",18)
print(p)
```



#### 12.5 多重继承

多重继承：一个子类可以有多个“直接父类”。

```python
#多重继承
class A:pass
class B:pass
class C(A,B):pass
c=C()
```



#### 12.6 super()方法

super()方法：获取父类定义,如父类的方法。

```python
# super()测试
class A:
    def say(self):
        print("A:",self)
        print("say A")
class B(A):
    def say(self):
        super().say()   #通过 super()调用父类的方法
        print("say B")
 
b=B()
b.say()
```



### 13 多态

多态（polymorphism）是指同一个方法调用由于对象不同可能会产生不同的行为。

- 多态是方法的多态，属性没有多态。
- 多态的存在有 2 个必要条件：继承、方法重写。

```python
#多态
class Animal:
    def shout(self):
        print("动物叫了一声")
 
class Dog(Animal):
    def shout(self):
        print("小狗，汪汪汪")
 
class Cat(Animal):
    def shout(self):
        print("小猫，喵喵喵")
 
def animalShout(a):
    if isinstance(a,Animal):
        a.shout()   #传入的对象不同，shout 方法对应的实际行为也不同
 
animalShout(Dog())
animalShout(Cat())
```



### 14 特殊方法、运算符和特殊属性

| 方法                 | 说明       | 例子                   |
| -------------------- | ---------- | ---------------------- |
| `__init__`           | 构造方法   | 对象创建：p = Person() |
| `__del__`            | 析构方法   | 对象回收               |
| `__repr__`,`__str__` | 打印，转换 | print(a)               |
| `__call__`           | 函数调用   | a()                    |
| `__getattr__`        | 点号运算   | a.xxx                  |
| `__setattr__`        | 属性赋值   | a.xxx = value          |
| `__getitem__`        | 索引运算   | a[key]                 |
| `__setitem__`        | 索引赋值   | a[key]=value           |
| `__len__`            | 长度       | len(a)                 |



| 运算符         | 特殊方法                                               | 说明                               |
| -------------- | ------------------------------------------------------ | ---------------------------------- |
| +              | `__add__`                                              | 加法                               |
| -              | `__sub__`                                              | 减法                               |
| <,<=,==>,>=,!= | `__lt__`,`__le__`，`__eq__`,`__gt__`,`__ge__`,`__ne__` | 比较运算符                         |
| \|,^,&         | `__or__`,`__xor__`,`__and__`                           | 或、异或、与                       |
| <<,>>          | `__lshift__`,`__rshift__ `                             | 左移、右移                         |
| *,/,%,//       | `__mul__`,`__truediv__`,`__mod__`,`__floordiv__`       | 乘、浮点除、模运算（取余）、整数除 |
| **             | `__pow__`                                              | 指数运算                           |



| 特殊方法               | 含义                   |
| ---------------------- | ---------------------- |
| obj.`__dict__`         | 对象的属性字典         |
| obj.`__class__`        | 对象所属的类           |
| class.`__bases__`      | 类的基类元组（多继承） |
| class.`__base__`       | 类的基类               |
| class.`__mro__`        | 类层次结构             |
| class.`__subclasses__` | 子类列表               |



### 15 浅拷贝和深拷贝

- 变量的赋值操作，只是形成两个变量，实际还是指向同一个对象。
- 浅拷贝，拷贝时，对象包含的子对象内容不拷贝，源对象和拷贝对象会引用同一个子对象。
- 深拷贝，使用 copy 模块的 deepcopy 函数，递归拷贝对象中包含的子对象，源对象和拷贝对象所有的子对象也不同。

```python
#测试对象的引用赋值、浅拷贝、深拷贝
import copy
class MobilePhone:
    def __init__(self,cpu,screen):
        self.cpu=cpu
        self.screen=screen
class CPU:
    def calculate(self):
        print("计算")
        print("CPU对象:",self)
class Screen:
    def show(self):
        print("好看的画面")
        print("屏幕对象:",self)
 
c=CPU()
s=Screen()
m=MobilePhone(c,s)
 
n=m     #两个变量，但是指向了同一个对象
print(m,n)
 
m2=copy.copy(m)
print(m,m2)
m.cpu.calculate()   #m2和m拥有了一样的cpu对象和screen对象
m2.cpu.calculate()
 
m3=copy.deepcopy(m)
print(m,m3)
m.cpu.calculate()   #m3和m拥有不一样的cpu对象和screen对象
m3.cpu.calculate()
```



### 16 设计模式

最常用的设计模式：工厂模式和单例模式。

- 工厂模式：实现了创建者和调用者的分离，使用专门的工厂类将选择实现类、创建对象进行统一的管理和控制。
- 单例模式(Singleton Pattern)：的核心作用是确保一个类只有一个实例，并且提供一个访问该实例的全局访问点

```python
# 设计模式_工厂模式实现
class CarFactory:
    def createCar(self,brand):
        if brand=="奔驰":
            return Benz()
        elif brand=="宝马":
            return BMW()
        elif brand=="比亚迪":
            return BYD()
        else:
            return "未知品牌，无法创建"
 
class Benz:pass
class BMW:pass
class BYD:pass
 
factory=CarFactory()
c1=factory.createCar("奔驰")
c2=factory.createCar("宝马")
print(c1)
print(c2)
```

```python
# 设计模式_单例模式实现
class MySingleton:
    __obj=None
    __init_flag=True
    def __new__(cls, *args, **kwargs):
        if cls.__obj==None:
            cls.__obj=object.__new__(cls)
        return cls.__obj
    def __init__(self,name):
        if MySingleton.__init_flag:
            print("init......")
            self.name=name
            MySingleton.__init_flag=False
 
a=MySingleton("A")
print(a)
b=MySingleton("B")
print(b)
```







