## 数组



数组是相同类型数据的有序集合。

- 长度是确定的。数组一旦被创建，它的大小就是不可以改变的。
- 其元素必须是相同类型，不允许出现混合类型。
- 数组类型可以是任何数据类型，包括基本类型和引用类型。



### 一、数组声明

```java
type[]   arr_name; //（推荐使用这种方式）
type    arr_name[];
```



【1】基本类型数组

```java
/**
 * 测试基本类型数组
 * @author 林
 *
 */
public class TestArray {
	public static void main(String[] args) {
		int[] s=new int[10];
		for(int i=0;i<10;i++) {
			s[i]=i*10;
			System.out.println(s[i]);
		}
	}
}
```



【2】引用类型数组

```java
/**
 * 测试引用类型数组
 * @author 林
 *
 */
public class TestArray {
	public static void main(String[] args) {
		Man[] m=new Man[10];
		Man m1=new Man(1001,17);
		Man m2=new Man(1002,18);
		m[0]=m1;
		m[1]=m2;
		for(int i=0;i<m.length;i++) {
			System.out.println(m[i]);
		}
	}
}
 
class Man{
	private int id;
	private int age;
	public Man(int id,int age) {
		super();
		this.id=id;
		this.age=age;
	}
}
```



### 二、数组初始化

【1】静态初始化

```java
int[] a = { 1, 2, 3 };	// 静态初始化基本类型数组；
Man[] mans = { new Man(1, 1), new Man(2, 2) };	// 静态初始化引用类型数组；
```



【2】动态初始化

```java
int[] a1 = new int[2];	//动态初始化数组，先分配空间；
a1[0]=1;	//给数组元素赋值；
a1[1]=2;	//给数组元素赋值；
```



### 三、for-each循环

```java
public class Test {
    public static void main(String[] args) {
        String[] ss = { "aa", "bbb", "ccc", "ddd" };
        for (String temp : ss) {
            System.out.println(temp);
        }
    }
}
```



### 四、数组拷贝

```java
/**
 * 测试数组拷贝
 * @author 林
 *
 */
public class TestArray {
	public static void main(String[] args) {
		String[] s1= {"百度","华为","阿里","腾讯"};
		String[] s2=new String[4];
		System.arraycopy(s1, 0, s2, 0, s1.length);
		for(int i=0;i<s2.length;i++) {
			System.out.print(s2[i]+"\t");
		}
	}
}
```



### 五、Arrays类

#### 5.1 打印数组

```java
import java.util.Arrays;
 
/**
 * 测试打印数组
 * @author 林
 *
 */
public class TestArray {
	public static void main(String[] args) {
		int[] a= {10,20};
		System.out.println(a);
		System.out.println(Arrays.toString(a));		//打印数组
	}
}
```



#### 5.2 数组元素排列

```java
import java.util.Arrays;
 
/**
 * 测试排列数组
 * @author 林
 *
 */
public class TestArray {
	public static void main(String[] args) {
		int[] a= {10,90,20,50,80,40};
		Arrays.sort(a);		//排列数组（升序）
		System.out.println(Arrays.toString(a));
	}
}
```



### 六、多维数组

【1】二维数组的声明

```java
public class TestArray {
	public static void main(String[] args) {
		int[][] a=new int[3][];		//二维数组的声明
		a[0]=new int[2];
		a[1]=new int[4];
		a[2]=new int[3];		
	}
}
```



【2】二维数组的静态初始化

```java
public class TestArray {
	public static void main(String[] args) {
		int[][] a= {{1,2,3},{10,20,30},{'a','b','c'}};	//二维数组的静态初始化
	}
}
```



【3】二维数组的动态初始化

```java
public class TestArray {
	public static void main(String[] args) {
		int[][] a=new int[3][];
		a[0]=new int[] {1,2};	//二维数组的动态初始化
		a[1]=new int[] {1,2,3};
		a[2]=new int[] {10,20};
		System.out.println(a[2][1]);
	}
}
```



【4】获取数组长度

```java
System.out.println(a.length);        //获取的二维数组第一维数组的长度。
 
System.out.println(a[0].length);    //获取第二维第一个数组长度。
```



【5】二维数组保存表格数据

```java
import java.util.Arrays;
 
/**
 * 二维数组保存表格数据
 * @author 林
 *
 */
public class TestArray {
	public static void main(String[] args) {
		Object[] a1= {1001,"林一",18,"2020-01-01"};
		Object[] a2= {1002,"林二",17,"2021-01-01"};
		Object[] a3= {1003,"林三",19,"2022-01-01"};
		Object[][] emps=new Object[3][];
		emps[0]=a1;
		emps[1]=a2;
		emps[2]=a3;
		System.out.println(Arrays.toString(emps[0]));
		System.out.println(Arrays.toString(emps[1]));
		System.out.println(Arrays.toString(emps[2]));
	}
}
```



### 七、算法

#### 7.1 冒泡算法

冒泡排序步骤：

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。



```java
import java.util.Arrays;
 
/**
 * 测试冒泡排序算法
 * @author 林
 *
 */
public class TestArray {
	public static void main(String[] args) {
		int[] values= {3, 1, 6, 2, 9, 0, 7, 4, 5, 8};
		bubbleSort(values);
		System.out.println(Arrays.toString(values));
	}
	
	public static void bubbleSort(int[] values) {
		int temp;
		for(int i=0;i<values.length;i++) {
			for(int j=0;j<values.length-1-i;j++) {
				if(values[j]>values[j+1]) {
					temp=values[j];
					values[j]=values[j+1];
					values[j+1]=temp;
				}
			}
		}
	}
}
```



```java
import java.util.Arrays;
 
/**
 * 测试冒泡排序算法（优化版）
 * @author 林
 *
 */
public class TestArray {
	public static void main(String[] args) {
		int[] values= {3, 1, 6, 2, 9, 0, 7, 4, 5, 8};
		bubbleSort(values);
		System.out.println(Arrays.toString(values));
	}
	
	public static void bubbleSort(int[] values) {
		int temp;
		for(int i=0;i<values.length;i++) {
			boolean flag=true;
			for(int j=0;j<values.length-1-i;j++) {
				if(values[j]>values[j+1]) {
					temp=values[j];
					values[j]=values[j+1];
					values[j+1]=temp;
					flag=false;
				}
			}
			if(flag) {
				break;
			}
		}
	}
}
```



#### 7.2 二分法查找

```java
import java.util.Arrays;
 
/**
 * 测试二分法查找
 * @author 林
 *
 */
public class TestArray {
	public static void main(String[] args) {
		int[] arr={30,20,50,10,80,9,7,12,100,40,8};
		int searchWord=30;
		Arrays.sort(arr);	//二分法查找之前，一定要对数组元素排序
		System.out.println(Arrays.toString(arr));
		System.out.println(binarySearch(arr,searchWord));
		
	}
	
	public static int binarySearch(int[] array,int value) {
		int low=0;
		int high=array.length-1;
		while(low<=high) {
			int middle=(low+high)/2;
			if(value==array[middle]) {
				return middle;
			}
			if(value>array[middle]) {
				low=middle+1;
			}
			if(value<array[middle]) {
				high=middle-1;
			}
		}
		return -1;
	}
}
```

