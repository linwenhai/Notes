## 继承



#### 一、父类与子类

##### 1.1 定义子类

关键字 extends 表示继承，子类继承父类的属性和方法，不包括构造器。

```java
class Employee{}	//父类

class Manager extends Employee{}	//子类继承父类
```



##### 1.2 方法覆盖

重写父类方法，称为覆盖（override)  。

```java
class Employee {
    ...
    public double getSalary(){
        return salary;
    }
}

class Manager extends Employee {
    ...
    @Override
    public double getSalary(){	//方法覆盖
        double baseSalary = super.getSalary();
        return baseSalary + bonus;
    }
}
```



##### 1.3 super关键字

super关键字用途：调用父类方法和构造器。

```java
double baseSalary = super.getSalary();	//调用父类普通方法	
```

```java
public Manager(String name, double salary){
	super(name, salary);	//调用父类构造器
	bonus = 100000;
}
```



##### 1.4 子类构造器

如子类构造器没有显式调用父类构造器，则自动调用父类无参构造器。



##### 1.5 多态

多态指的是同一个方法调用，由于对象不同可能会有不同的行为。 

【多态要点】

- 多态是方法的多态，不是属性的多态(多态与属性无关)。
- 多态的存在要有3个必要条件：**继承**，**方法重写**，**父类引用指向子类对象**。
- 父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了。
- 多态无法调用子类特有的方法，如调用需类型转换。

```java
package com.test.java;

public class TestJava {
	public static void main(String[] args) {
		Animal a1=new Dog();	//父类引用指向子类对象
		Animal a2=new Cat();
		animalCry(a1);		//传的具体是哪一个类就调用哪一个类的方法
		animalCry(a2);
		
		Dog d1=(Dog)a1;		//强制类型转换
		d1.seeDoor();
	}
	
	//父类引用做方法的形参，实参可以是任意的子类对象
	static void animalCry(Animal a) {	//多态避免写多个重载方法，减少代码量
		a.shout();
	}
}

class Animal {
    public void shout() {
        System.out.println("动物叫了一声！");
    }
}
class Dog extends Animal {	//继承
	@Override
    public void shout() {	//方法重写
        System.out.println("旺旺旺！");
    }
	public void seeDoor() {
        System.out.println("看门中....");
    }
}
class Cat extends Animal {	//继承
	@Override
    public void shout() {	//方法重写
        System.out.println("喵喵喵喵！");
    }
}
```



##### 1.6 阻止继承

不允许扩展的类被称为 final 类。  

```java
public final class Executive extends Manager{}
```



##### 1.7 类型转换

将一个子类的引用赋给一个父类变量，编译器允许。

将一个父类的引用赋给一个子类变量，需强制转换。

```java
Animal a1=new Dog();	//ok,子类引用赋予父类变量
Dog d1=(Dog)a1;			//父类引用赋予子类变量，需强制转换
```



##### 1.8 抽象类

使用 abstract 关键字的类都是抽象类。

```java
public abstract class Person {	//抽象类
    ...
	public abstract String getDescription();	//抽象方法
}
```





#### 二、Object类

Object 类是 Java 中所有类的始祖， 在 Java 中每个类都是由它扩展而来的。  

##### 2.1 equals 方法

判断2个字符串值是否相同，使用equals 方法。

```java
public class TestEquals {
	public static void main(String[] args) {
		String s1=new String("林一");
		String s2=new String("林一");
		
		System.out.println(s1==s2);			//false, 两个字符串不是同一个对象
		System.out.println(s1.equals(s2));	//true,  两个字符串内容相同
	}
}
```



##### 2.2 hashCode 方法

散列码（ hash code ) 是由对象导出的一个整型值。 散列码是没有规律的。  

```java
public class TestJava {
	public static void main(String[] args) {
		String s1="Hello";
		StringBuilder s2=new StringBuilder(s1);
		System.out.println("s1.hashCode: "+s1.hashCode());
		System.out.println("s2.hashCode: "+s2.hashCode());
		String s3=new String("Hello");
		StringBuilder s4=new StringBuilder(s3);
		System.out.println("s3.hashCode: "+s3.hashCode());	//s1与s3 hashCode相同
		System.out.println("s4.hashCode: "+s4.hashCode());
	}
}
```

>输出结果：
>
>s1.hashCode: 69609650
>s2.hashCode: 366712642
>s3.hashCode: 69609650
>s4.hashCode: 1829164700
>
>s1与s2散列码相同，原因：字符串的散列码是由内容导出的。
>s3与s4散列码不相同，原因： StringBuffer类中没有定义hashCode方法，它的散列码是由Object类的默认hashCode方法导出的对象存储地址。



##### 2.3 toString方法

toString 方法：它用于返回表示对象值的字符串。

Object 类定义了 toString 方法， 用来打印输出对象所属的类名和散列码。  

```java
public class TestJava {
	public static void main(String[] args) {
		System.out.println(System.out);
	}
}
```

>输出结果：
>
>java.io.PrintStream@15db9742



强烈建议为自定义的每一个类增加 toString 方法。  



#### 三、泛型

##### 3.1 ArrayList类

ArrayList 是一个采用类型参数（ type parameter ) 的泛型类（ generic class )。   

```java
ArrayList<Employee> a1 = new ArrayList<Employee>();		//泛型
```

>new ArrayListo() 将赋至一个类型为 ArrayList<Employee> 的变量， 所以泛型类型为 Employee。  



```java
a1.add(new Employee("林一"));		//添加对象到数组
a1.add(new Employee("林二"));
```



```java
a1.size();		//返回数组元素数量，等价于a1.length
```



```java
a1.set(0,"林三");		//设置索引为0的元素为“林三”
```



```java
Employee e=a1.get(0);	//获取索引为0的元素值
```



##### 3.2 包装器和自动装箱





#### 四、可变参数

省略号 . . . 是 Java 代码的一部分，它表明这个方法可以接收任意数量的对象  

```java
public static double max(double... values){}
```





#### 五、枚举类





#### 六、反射

能够分析类能力的程序称为反射（reflective )。  





#### 七、继承设计技巧

1. 将公共操作和域放在超类。
2. 不要使用受保护的域。
3. 使用继承实现“ is-a” 关系。
4. 除非所有继承的方法都有意义，否则不要使用继承。
5. 在覆盖方法时， 不要改变预期的行为。
6. 使用多态，而非类型信息。
7. 不要过多地使用反射。

















